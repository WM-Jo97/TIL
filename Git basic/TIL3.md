<details>
<summary><h2>데이터 구조</h2></summary>
<div markdown="1">
1. 데이터 구조 활용
    데이터 구조를 활용하기 위해서는 메서드(method)를 활용
    * 메서도는 클래스 내부에 정의한 함수, 사실상 함수 동일

2. 데이터 구조
    1) 순서가 있는 데이터 구조
        
        ㄱ) 문자열(String Type)
            
            *문자들의 나열 (모든 문자는 str타입)
            *문자열은 작은 따옴표나 큰따옴표를 활용하여 표기
            *문자열을 묶을 때 동일한 문장부호를 활용
            *PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함
        
            i) 문자열 조회/탐색 및 검증 메서드

                *S.find(x) : x의 첫번쨰 위치, 없으면 -1 반환
                *S.index(x) : x의 첫번쨰 위치, 없으면 에러
                *S.isalpha() : 알파벳 문자 여부
                *S.isupper() : 대문자 여부
                *S.islower() : 소문자 여부
                *S.istitle() : 타이틀 형식 여부
            
            ii) 문자열 변경 메서드

                *S.replace(old,new[,count]) : 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
                *S.strip() : 공백이나 특정 문자를 제거
                *S.split() : 공백이나 특정 문자를 기준으로 분리
                *S.capitalize() : 가장 첫번쨰 글자를 대문자로 변경
                *S.title() : 문자열 내 띄워쓰기 기준으로 각 단어의 첫번재 글자는 대문자, 나머지는 소문자
                *S.upper() : 모두 대문자로
                *S.lower() : 모두 소문자로
                *S.swapcase() : 대 , 소문자 서로 변경

            iii) 문자열은 immutable 이지만 새로운 문자열을 생성해서 문자열을 변경

        2) 리스트 자료형 (List)

            리스트는 여러개의 값을 순서가 있는 구조로 저장하고 싶을 떄 사용

            i) 리스트의 생성과 접근
                리시트는 대괄호 또는 list()로 생성
            
            ii) 리스트메서드
                
                l.append(x) : 리스트 마지막에 x 추가
                l.insert(i,x) : 리스트 인덱스 i에 x를 삽입
                l.remove(x) : 리스트 가장 왼쪽에 있는 항목 x를 제거
                l.pop() : 리스트 가장 오른쪽에 있는 마지막 항목 반환 후 제거
                l.extend(m) : 순회형 m의 모든 항목들의 리스트 끝에 추가
                l.index(x, start, end) : 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환
                l.reverse() : 리스트를 거꾸로 정렬
                l.sort() : 리스트 정렬
                l.count(x) : 리스트에서 x가 몇개 존재하는지 반환

        3) 튜플 (Tuple)

            여러 개의 값을 순서가 있는 구조로 저장
            (리스트와 차이점 : 생성 후 담고 있는 값 변경 불가)

            i) 튜플 메서드 : 리스트 메서드와 거의 대부분 일치

        4)연산자
            
            Membership 연산자
                멤버십 연산자 in을 통해 특정 요소가 속해 있는지 여부를 확인
            Sequence type 연산자
                산술 연산자 + : 시퀀스 간의 연결
                반복 연산자 * : 시퀀스를 반복

    2. 순서가 없는 데이터 구조

        1) 셋(Set)

            Set이란 중복되는 요소 없이, 순서에 상관없는 데이터들의 묶음
                중복허용하지 않음, 인덱스로 접근 불가

            i) Set 메서드

                s.copy() : 셋의 얕은 복사본을 반환
                s.add(x) : 항목x가 셋 s에 없다면 추가
                s.pop() : 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거 (set이 비어있으면 keyerror)
                s.remove(s) : 항목 x를 셋s에서 삭제, 항목 존재하지 않으면 key error
                s.discard(x) : 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제
                s.update(t) : 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가
                s.clear() : 모든 항목을 제거
                s.isdisjoint(t) : 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않으면 true 반환
                s.issubset(t) : 셋 s가 셋t의 하위 셋인 경우, True
                s.issuperset(t) : 셋 s가 셋 t의 상위 셋인 경우, True        
        
        2) 딕셔너리 (Dictionary)

            키-값 쌍으로 이루어진 자료형
            Dictionary의 키는 변경 불가능한 데이터만 활용 가능

                i) Dictionary 메서드

                    d.clear() : 모든 항목을 제거
                    d.copy() : 딕셔너리의 d의 얕은 복사본을 반환
                    d.keys() : 딕셔너리 d의 모든 키를 담은 뷰를 반환
                    d.values() : 딕셔너리 d의 모든 값을 담은 뷰를 반환
                    d.items() : 딕셔너리 d의 모든 키-값 쌍을 담은 뷰를 반환
                    d.get(k) : 키 k의 값을 반환, 없으면 None
                    d.get(k,v) : 키 k의 값을 반환, 없으면 v
                    d.pop(k) : 키 k의 값을 반환, 키 k인 항목을 딕셔너리 d에서 삭제,
                               키가 없으면 keyerror
                    d.pop(k,v) : 키 k의 값을 반환하고 k인 항목을 딕셔너리 d에서 삭제
                               키 k가 딕셔너리 d에 없을 경우 v 반환
                    d.update() : 딕셔너리 d의 값을 매핑하여 업데이트

3. 얕은 복사와 깊은 복사
    
    1) 할당
        
        대입 연산자(=)
        -> 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

    2) 얕은 복사

        Slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사
    
    3) 깊은 복사
        
        -> 원본과 복사본이 전혀 다른 개체가 됨

</div>
</details>