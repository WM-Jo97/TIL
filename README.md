# TIL
천천히 가더라도 제대로 갑니다

![펭하](/Git%20basic/img/ps.jpg)

<details>
  <summary> <h2>Python Basic</h2>  </summary>
<div markdown="1">
  
1) Python 특징
  
    * 인터프리터 언어 -> 컴파일러 언어에 비해 상대적으로 속도는 느리지만 프로그래밍이 용이함
    * 타 언어에 비해 문법이 간결하고 유연
  
2) 객체 지향 프로그래밍
  
  -> 프로그래밍에는 객체지향과 절차 지향 프로그래밍이 존재함.
  
     일반적으로 실생활에 쓰는 모든 것을 객체라고 하며, 객체지향 프로그래밍이란
     프로그램에 필요한 객체를 파악하고, 각각의 객체들의 역할이 무엇인지 정의하여 객체들 간의 
     상호작용을 통해 프로그램을 만드는 것.
  
     객체(Object)는 클래스라는 틀에서 생겨난 실체(Instance)임
  
     객체지향 프로그램은 객체와 객체간의 연결로 이루어져있으며, 객체 안에 자료구조와 알고리즘 있음.

   * 객체 지향 vs 절차 지향 프로그래밍
  
    -> 객체 지향 : 누가 어떤 일을 할 것 인가?
         * 대형 프로그래밍은 많은 기능을 수반하므로 객체 지향에 적합

       절차 지향 : 어떤 절차를 통해 일을 할 것 인가?
         * 소형 프로그래밍의 경우 적은 기능을 수반하므로 프로그래밍이 용이한 절차 지향이 적합

   * 객체지향 프로그래밍 특징
  
    1. 추상화
      * 객체들의 공통적 특징을 도출하는 것
      * 객체 지향적 관점에서는 클래스를 정의하는 것 : 추상화
  
    2. 캡슐화 
      * 구현되는 부분을 외부에 드러내지 않도록 정보를 은닉
      * 객체가 독립적 역할을 할 수 있도록 데이터와 기능을 하나로 묶어 관리
      * 외부와 상호작용할 때 메소드를 활용
  
    3. 상속성
      * 하나의 클래스가 가진 특성을 다른 클래스가 그대로 물려받을 수 있음
      * 이미 작성된 클래스를 받아 새로운 클래스를 생성
      * 기존 코드를 재활용하여 생산력 향상
  
    4. 다형성
      * 약간 다른 방법으로 동작하는 함수를 동일한 이름으로 호출
      * 동일한 명령의 해석을 연결된 객체에 의존
      * 오버라이딩(Overriding) : 부모클래스의 메소드와 같은 이름을 사용하며 매개변수도 같되 내부 소스를 재정의하는 것
      * 오버로딩(Overloading) : 같은 이름의 함수를 여러 개 정의한 후 매개변수를 다르게 하여 같은 이름을 경우에 따라 호출하여 사용하는 것
  
    5. 동적바인딩
      * 함수를 호출하면 동적 바인딩을 통해 파생 클래스에 오버라이딩된 함수가 실행
      * 프로그래밍의 유연성을 높여주며 파생 클래스에서 재정의한 함수의 호출을 보장

  -> 객체 지향 프로그래밍의 장점
  
    1. 소프트웨어 생산성 향상
    2. 현실 세계에 대한 모델링 용이
    3. 보안성 향상

  -> 객체 지향 프로그래밍의 단점
  
    1. 느린 실행 속도 (캡슐화와 격리구조 때문에 절차지향에 비해 느림)
    2. 객체지향에서는 모든 것을 객체로 생각하므로 메모리와 연산에 비용 소모
    3. 설계 시 작은 규모의 프로젝트의 경우 절차지향에 비해 복잡

</div>
</details>
<hr>
<details>
<summary><h2> Python 기본 문법 </h2></summary>
<div markdown="1">
1. 들여쓰기(Space Sensitive)
  
      -  문장을 구분할 때, 중괄호대신 들여쓰기 사용
         들여쓰기는 4칸 띄우기 혹은 Tap
         Tap과 4칸 띄워쓰기 혼용금지, 한가지 종류로만 사용
         원칙적으로는 공백(빈칸)을 권장
    
2. 주석 (Comment)
  
  -  코드를 보다 이해하기 쉽게하여 분석 및 수정이 용이
     주석은 코드에 영향을 줒 않으며, 개발 간 편의를 위해 사용
  
    한줄 주석 : #
    여러줄 주석 : ''' ~~ '''
    주석 단축키 : 컨트롤 + /

  
3. 변수(Variable)
  
  -> 데이터를 저장하기 위해 사용
     변수를 사용하면 복잡한 값을 쉽게 사용할 수 있음
     동일 변수에 다른 데이터를 언제든 할당(저장) 가능

    변수의 할당 => 변수(Variable) = 값 (Value)

    각 변수의 값을 바꿔서 저장 -> pythonic한 방법 => x, y = y, x

    식별자
  
      변수 이름 규칙
       1. 식별자의 이름은 영문 알파벳 , 언더스코어(_) , 숫자로 구성
       2. 첫 글자에 숫자가 올 수 없음
       3. 길이 제한이 없고 대소문자를 구분
       4. 파이썬에 미리 예약된 예약어는 사용 불가
       5. 내장 함수나 모듈 등의 이름도 사용하지 않아야 함

4. 연산자
  
  기본적인 사칙연산에 사용
  
      + : 덧셈
      - : 뺄셈
      * : 곱셈
      / : 나눗셈
      // : 몫
      ** : 제곱
      % : 나머지

5. 자료형 
  
  -- Python에서 사용할 수 있는 데이터의 Type

     (Data Type)  _ Boolean Type    _ Int
                 |                 |
                 |_ Numeric Type __|_ Float
                 |                 |
                 |_ String Type    |_ Complex

  1) Numeric Type (수치형 자료형)
  
    ㄱ) Int (정수)
        -> 진수표현 가능 (2진수 : 0b, 8진수 : 0o , 16진수 : 0x )
  
    ㄴ) Float (실수 자료형)
  
        -> 실수의 값을 처리할 때 의도하지 않은 값이 나올 수 있음
        (3.2 - 3.1 = 0.100000000000009)

        -> 부동소수점 때문 (Floating point rounding error)
  
         * 컴퓨터는 2진수를 사용하여 10진수 0.1은 2진수로 표현하면 01.00011001100110.... 으로
         * 무한대로 반복, 무한대 숫자를 그대로 저장할 수 없어 근사값만 표시
         * 매우 작은 수를 이용하여 비교하거나 math 모듈을 이용하여 해결 가능

  2) String Type (문자열 자료형)
    -- 모든 문자는 Str tpye
       작은 따옴표 ' 또는 큰 따옴표 " 를 이용하여 표기
       '우리는 "하나"' 또는 "우리는 '하나'" 와 같이 중첩하여 사용 가능

    * Escape sequence
      역슬래시 \ 뒤에 특정 문자가 와서 기능을 하는 문자
        \n : 줄바꿈
        \t : 탭
        \r : 캐리지 리턴
        \0 : null
        \\ : \
        \' : '
        \" : "

    * 문자열 연산
      "A" + "B" = "AB"
      "A" * 3 = "AAA"

    * f-string : print(f'Hello, {name}! 성적은 {score}')
        -> name = A , score = 80 일 때, 츨력값은 Hello, A! 성적은 80

  3) None
    -- 값이 없음을 표현하기 위해 None 타입 존재
       일반적으로 반환 값이 없는 함수에서 사용하기도 함

  4) Boolean 
    -- True 와 False를 값으로 가지며 참과 거짓을 표현

    * 비교 연산자
      < , > : 초과, 미만
      <=, >= : 이상, 이하
      == : 동일
      != : 같지 않음
      is : 객체 아이덴티티 (OPP)
      is not : 객체 아이덴티티가 아닌 경우 

    * 논리 연산자
      and = 둘 모두 True일 때, True
      or = 둘 중 하나만 True 면 True
      Not = True -> False , False -> True
      -> not, and, or 순으로 우선순위가 높음

    * Falsy : False는 아니지만 False로 취급되는 값
      -> 0, 0.0 , () , [], {}, None, ""

6. 컨테이너
        
  -- 여러 개의 값을 담을 수 있는 객체, 서로 다른 자료형을 저장할 수 있음
     컨테이너는 순서가 있는 Ordered Data 와 순서가 없는 Unordered Data로 구분
     (순서가 있다 = 정렬되어 있다는 의미는 아님)

    컨테이너 분류                        __ 리스트
                                       |
                 __ 시퀀스형 (순서 o) __|__ 튜플
                |                      |
    Container   |                      |__ 레인지
                |
                |__ 비시퀀스형 (순서 x) ____ 세트
                                        |
                                        |__ 딕셔너리

  1) 시퀀스형
        
    ㄱ) 리스트 : 여러 개의 값을 순서가 있는 구조로 저장하고싶을 때 사용
        -> 어떤 자료형도 저장 가능, 생성된 후 내용 변경 가능
           인덱스를 이용해 데이터에 접근 가능
    ㄴ) 튜플 : 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
        -> 리스트와 달리 담고 있는 값은 변경 불가능, 인덱스로 접근은 가능
           단일 항목의 경우 : 하나의 항목으로 구성된 튜플은 생성 시 값 뒤에 쉼표를 붙임
           복수 항목의 경우 : 마지막에 쉼표는 없어도 되지만, 넣는 것을 권장
           튜플 대입 -> x,y = 1, 2 라는 변수 선언은 실제로는 튜플로 처리
                       x,y = (1, 2)
    ㄷ) 레인지 : 숫자의 시퀀스를 나타내기 위해 사용, 주로 반복문과 함께 사용
        -> range(n) : 0~ n-1 까지의 숫자
           range(n,m) : n ~ m-1 까지의 숫자
           range(n, m, s) : n ~ m-1 까지 s씩 증가

    * 슬라이싱 연산자 : 시퀀스를 특정 단위로 슬라이싱 가능
        
      * 인덱스와 콜론을 사용하여 문자열의 특정 부분만 잘라낼 수 있음
      * 리스트, 튜플, range, 문자열에 사용가능
      * [n : m] -> n번쨰 ~ m-1 번째
      * [n : m : k] -> n ~ m-1 까지 k간격으로 슬라이싱

  2) 비시퀀스형
        
    ㄱ) 셋 : 중복되는 요소 없이, 순서에 상관없는 데이터의 묶음
             순서가 없으므로 인덱스를 통한 접근 불가능
             수학에서 집합을 표현한 컨데이너
             담고있는 요소를 삽입, 변경, 삭제 가능 (mutable 자료형)
        * 셋 연산자 
          * | : 합집합
          * & : 교집협
          * - : 차집합
          * ^ : 대칭차집합 
    ㄴ) 딕셔너리 : 키 - 값 (key - value) 쌍으로 이루어진 자료형
        key 는 변경 불가능한 (immutable) 자료형만 활용 가능
        * string, integer, float, boolean, tuple, range
        value 는 모든 데이터 사용 가능

7. 형변환
        
  -> 파이썬에서 데이터 형태는 서로 변환할 수 있음
        
    1) 암시적 형변환 : 사용자가 의도하지 않고 파이썬 내부적으로 자료형을 변환 (bool, int, float)
    2) 명시적 형변환 : 사용자가 특정 함수를 활용하여 의도적으로 자료형을 변환 (int, float, str )

</div>
</details>

<hr>

<details>
<summary><h2>Python기본문법2</h2></summary>
<div markdown="1">
1. 제어문
 -> 특정 상황에 따라 코드를 선택적으로 실행하거나 반복 실행하기 위해 사용
  제어문은 순서도(Flowchart)로 표현 가능

 1) 조건문
  
    참/ 거짓에 따라 분기가 나뉨
    
      if 조건 == True:
        분기 1
      else:
        분기 2

    ㄱ) 복수 조건문
      복수의 조건문은 elif를 이용해서 표현
      
        if 조건:
            분기 1
        elif 조건:
            분기 2
        elif 조건:
            분기 3
        else:
            분기 4

    ㄴ) 중첩 조건문
      조건문 안데 다른 조건문을 중첩해서 사용할 수 있음
      
        if 조건:
            if 조건:
                분기 1-1
            else:
                분기 1-2
        eles:
            분기 2

    ㄷ) 조건 표현식
  
      조건에 따라 값을 정할 때 활용
      삼항 연산자로도 불림
  
      'true인 경우 값 if 조건 else false인 경우 값'
  
        ex) X= A
        Y = A if type(X)==int else Y = B
        => Y = B

 2) 반복문
  
    특정 조건을 만족할 때까지 반복
  
    ㄱ) while문 : 종료 조건에 해당하는 코드를 통해 종료
  
    ㄴ) for문 : 반복 가능한 객체롤 모두 순회하면 자동 종료
  
      -> break, continue, for-else 등을 통해 제어 가능
  
      *List Comprehension : 표현식과 제어문을 통해 리스트를 간결하게 생성
          ex) [code for 변수 in iterable if 조건식]
    
    ㄷ) 반복문 제어

      * break : 반복문을 종료
      * continue : 이후 코드 블록은 수행하지 않고 다음 반복을 수행
      * for-else : 끝까지 반복문을 실행한 후 else문 실행
        (break를 통해 중간에 종료되면 else문은 실행되지 않음)
      * pass : 아무것도 하지 않음

2. 함수
   
   -> 함수는 Decomposition(분해), Abstracion(추상화)가 가장 큰 키워드
     Decomposition : 기능을 분해하고 재사용 가능하게 하기
     Abstraction : 복잡한 내부 정보를 모르더라도 사용 가능하게 하기
  
1) 함수의 종류
   
   * 내장함수 : 파이썬에 기본 내장된 함수
   * 외장함수 : import문을 통해 외부 라이브러리에서 불러온 함수
   * 사용자 정의 함수 : 사용자가 직접 만든 함수               

2) 함수의 정의
   
   * 함수(Function)
   - 특정한 기능을 하는 코드의 조각
   
   - 특정 코드를 매번 다시 작성하지 않고 필요시에만 호출하여 간편하게 사용
   * 기본 구조
  
       def name(data, parameters):
       ```
       ```
       return answer
   
   * 선언과 호출 (define & call)
  
   - 함수의 선언은 def 키워드를 활용함
   - 들여쓰기를 통해 Function body를 작성
   - 함수는 parameter를 넘겨줄 수 있음
   - 함수는 동작후에 return을 통해 결괏값을 전달함

3) 함수의 결과값(Outout)
   
   *Void function
    명시적인 return 값이 없는 경우, None을 반환하고 종료
   
   *Value returning function
    함수 실행 후, return문을 통해 값 반환
    return을 하게 되면, 값 반환 후 함수가 바로 종료
   
   *print vs return
    print함수와 return의 차이점
    -> print를 사용하면 호출될 때마다 값이 출력됨(주로 테스트를 위해 사용)
    -> 데이터 처리를 위해서는 return 사용

4) 함수의 입력(Input)
   
   *Parameter 와 Argument
   
   - Parameter : 함수를 정의할 때, 함수 내부에서 사용되는 변수
   - Argument : 함수를 호출할 때, 넣어주는 값
     ->함수 호출 시 함수의 parameter를 통해 전달되는 값
       Argument는 소괄호 안에 할당 func_name(argument)
     * 필수 Argument : 반드시 전달되어야 하는 argument
     * 선택 Argument : 값을 전달하지 않아도 되는 경우는 기본값이 전달
       Argument는 위치에 따라, 직접 값을 지정하여, default 값을 미리 지정해서 사용

5) 가변인자 (*args)
   
   *가변인자 : 여러 개의 Positional Argument를 하나의 필수 parameter로 받아서 사용
    -> 몇 개의 Positional Argument를 받을지 모르는 함수를 정의할 때 유용
   
   패킹, 언패킹

     -> 패킹 : 여러 개의 데이터를 묶어서 변수에 할당하는 것
  
     -> 언패킹 : 시퀀스 속의 요소들을 여러 개의 변수에 나누어 할당하는 것
  
     -> 언패킹시 변수의 개수와 할당하고자 하는 요소의 갯수가 동일해야함
  
     -> 언패킹시 왼쪽의 변수에 * 를 붙이면 할당하고 남은 요소를 리스트에 담을 수 있음
  
     *는 스퀀스 언패킹 연산자라고도 불리며, 말 그대로 시퀀스를 풀어 헤치는 연산자

6) 가변 키워드 인자 (**kwargs)
   
   * 몇 개의 키워드 인자를 받을지 모르는 함수를 정의할 때 유용
   * **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **를 붙여 표현
</div>
</details>
<hr>
<details>
<summary><h2>데이터 구조</h2></summary>
<div markdown="1">
1. 데이터 구조 활용
    데이터 구조를 활용하기 위해서는 메서드(method)를 활용
    * 메서도는 클래스 내부에 정의한 함수, 사실상 함수 동일

2. 데이터 구조
    1) 순서가 있는 데이터 구조
        
        ㄱ) 문자열(String Type)
            
            *문자들의 나열 (모든 문자는 str타입)
            *문자열은 작은 따옴표나 큰따옴표를 활용하여 표기
            *문자열을 묶을 때 동일한 문장부호를 활용
            *PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함
        
            i) 문자열 조회/탐색 및 검증 메서드

                *S.find(x) : x의 첫번쨰 위치, 없으면 -1 반환
                *S.index(x) : x의 첫번쨰 위치, 없으면 에러
                *S.isalpha() : 알파벳 문자 여부
                *S.isupper() : 대문자 여부
                *S.islower() : 소문자 여부
                *S.istitle() : 타이틀 형식 여부
            
            ii) 문자열 변경 메서드

                *S.replace(old,new[,count]) : 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
                *S.strip() : 공백이나 특정 문자를 제거
                *S.split() : 공백이나 특정 문자를 기준으로 분리
                *S.capitalize() : 가장 첫번쨰 글자를 대문자로 변경
                *S.title() : 문자열 내 띄워쓰기 기준으로 각 단어의 첫번재 글자는 대문자, 나머지는 소문자
                *S.upper() : 모두 대문자로
                *S.lower() : 모두 소문자로
                *S.swapcase() : 대 , 소문자 서로 변경

            iii) 문자열은 immutable 이지만 새로운 문자열을 생성해서 문자열을 변경

        2) 리스트 자료형 (List)

            리스트는 여러개의 값을 순서가 있는 구조로 저장하고 싶을 떄 사용

            i) 리스트의 생성과 접근
                리시트는 대괄호 또는 list()로 생성
            
            ii) 리스트메서드
                
                l.append(x) : 리스트 마지막에 x 추가
                l.insert(i,x) : 리스트 인덱스 i에 x를 삽입
                l.remove(x) : 리스트 가장 왼쪽에 있는 항목 x를 제거
                l.pop() : 리스트 가장 오른쪽에 있는 마지막 항목 반환 후 제거
                l.extend(m) : 순회형 m의 모든 항목들의 리스트 끝에 추가
                l.index(x, start, end) : 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환
                l.reverse() : 리스트를 거꾸로 정렬
                l.sort() : 리스트 정렬
                l.count(x) : 리스트에서 x가 몇개 존재하는지 반환

        3) 튜플 (Tuple)

            여러 개의 값을 순서가 있는 구조로 저장
            (리스트와 차이점 : 생성 후 담고 있는 값 변경 불가)

            i) 튜플 메서드 : 리스트 메서드와 거의 대부분 일치

        4)연산자
            
            Membership 연산자
                멤버십 연산자 in을 통해 특정 요소가 속해 있는지 여부를 확인
            Sequence type 연산자
                산술 연산자 + : 시퀀스 간의 연결
                반복 연산자 * : 시퀀스를 반복

    2. 순서가 없는 데이터 구조

        1) 셋(Set)

            Set이란 중복되는 요소 없이, 순서에 상관없는 데이터들의 묶음
                중복허용하지 않음, 인덱스로 접근 불가

            i) Set 메서드

                s.copy() : 셋의 얕은 복사본을 반환
                s.add(x) : 항목x가 셋 s에 없다면 추가
                s.pop() : 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거 (set이 비어있으면 keyerror)
                s.remove(s) : 항목 x를 셋s에서 삭제, 항목 존재하지 않으면 key error
                s.discard(x) : 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제
                s.update(t) : 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가
                s.clear() : 모든 항목을 제거
                s.isdisjoint(t) : 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않으면 true 반환
                s.issubset(t) : 셋 s가 셋t의 하위 셋인 경우, True
                s.issuperset(t) : 셋 s가 셋 t의 상위 셋인 경우, True        
        
        2) 딕셔너리 (Dictionary)

            키-값 쌍으로 이루어진 자료형
            Dictionary의 키는 변경 불가능한 데이터만 활용 가능

                i) Dictionary 메서드

                    d.clear() : 모든 항목을 제거
                    d.copy() : 딕셔너리의 d의 얕은 복사본을 반환
                    d.keys() : 딕셔너리 d의 모든 키를 담은 뷰를 반환
                    d.values() : 딕셔너리 d의 모든 값을 담은 뷰를 반환
                    d.items() : 딕셔너리 d의 모든 키-값 쌍을 담은 뷰를 반환
                    d.get(k) : 키 k의 값을 반환, 없으면 None
                    d.get(k,v) : 키 k의 값을 반환, 없으면 v
                    d.pop(k) : 키 k의 값을 반환, 키 k인 항목을 딕셔너리 d에서 삭제,
                               키가 없으면 keyerror
                    d.pop(k,v) : 키 k의 값을 반환하고 k인 항목을 딕셔너리 d에서 삭제
                               키 k가 딕셔너리 d에 없을 경우 v 반환
                    d.update() : 딕셔너리 d의 값을 매핑하여 업데이트

3. 얕은 복사와 깊은 복사
    
    1) 할당
        
        대입 연산자(=)
        -> 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

    2) 얕은 복사

        Slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사
    
    3) 깊은 복사
        
        -> 원본과 복사본이 전혀 다른 개체가 됨

</div>
</details>

<details>
  <summary> <h2>WEB</h2>  </summary>
<div markdown="1">
  
1) WEB 구성요소
  
    * HTML => 구조
    * CSS => 표현
    * Javascript => 동작

2) WEB 사이트와 브라우저
  
  -> 웹 사이트는 브라우저를 통해 동작함, 브라우저마다 동작이 달라 문제가 생기는 경우가 많음
   => 해결책으로 웹 표준이 등장

3) HTML
  
    -> HTML : Hyper Text Markup Language
         * Hyper Text = 참조를 통해 사용자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트
         * Markup Language = 태그 등을 이용하여 문서나 데이터의 구조를 명시하는 언어
       
       
       HTML 기본 구조
         * HTML : 문서의 최상위(root) 요소
         * HEAD : 문서 메타데이터 요서
             문서 제목, 인코딩, 스타일, 외부 파일 로딩 등
             일반적으로 브라우저에  나타나지 않는 내용
         * BODY : 문서 본문 요소
             실제 화면 구성과 관련된 내용

       head 예시
         <title> : 브라우저 상단 타이틀
         <meta> : 문서 레벨 메타데이터 요소
         <link> : 외부 리소스 연결 요소 (CSS파일, favicon 등)
         <script> : 스크립트 요소 (Javascript파일/ 코드)
         <style> : CSS 직접 작성

    -> 요소(element)
         * HTML 요소는 시작 태그와 종료 태그 그리고 태그 사이에 위치한 내용으로 구성
            요소는 태그로 컨텐츠를 감싸는 것으로 그 정보의 성격과 의미를 정의
            내용이 없는 태그도 존재 (br, hr, img, input, link, meta)
         * 요소는 중첩될 수 있음
            요소의 중첩을 통해 하나의 문서를 구조화
            여는 태그와 닫는 태그의 쌍을 잘 확인해야함
                오류를 반환하는 것이 아닌 그냥 레이아웃이 깨진 상태로 출력되기 때문에, 디버깅이 힘들어 짐

    -> 속성(attribute)
         * 속성을 통해 태그의 부가적인 정보를 설정할 수 있음
         * 요소는 속성을 가질 수 있으며, 경로나 크기와 같은 추가적인 정보를 제공
         * 요소의 시작 태그에 작성하며 보통 이름과 값이 하나의 쌍으로 존재
         * 태그와 상관없이 상요 가능한 속성(HTML Global Attribute)들도 있음

        HTML Global Attribute
          * 모든 HTML요소가 공통으롷 사용할 수 있는 대표적인 속성 (몇몇 요소에는 아무 효과가 없을 수 있음)
            ID : 문서 전체에서 유일한 고유 식별자 지정
            class : 공백으로 구분된 해당 요소의 클래스의 목록 (CSS, JS에서 요소를 선택하거나 접근)
            data-* : 페이지에 개인 사용자 정의 데이터를 저장하기 위해 사용
            style : inline 스타일
            title : 요소에 대한 추가 정보 지정
            tabindex : 요소의 탭 순서
    
    -> 시맨틱 태그
         * HTML 태그가 특정 목적, 역할 및 의미적 가치를 가지는 것
            예를 들엉 H1태그는 '이 페이지에서 최상위 제목' 인 텍스트를 감싸는 역할을 나타냄
         * Non semantic 요소로는 div, span등이 있으며, a, form, table 태그들도 시맨틱 태그로 볼 수 있음
         * HTML5에서는 기존에 단순히 콘텐츠의 구획을 나타내기 위해 사용한 div 태그를 대체하여 사용하기 위해 의미론적 요소를 담은 태그들이 추가됨
         * 대표적인 시맨틱 태그 목록
            * header : 문서 전체나 섹션의 헤더
            * nav : 네비게이션
            * aside : 사이드에 위치한 공간, 메인 콘텐츠와 관련성이 적은 콘텐츠
            * section : 문서의 일반적인 구분, 컨텐츠의 그룹을 표현
            * article : 문서, 페이지, 사이트 안에서 독립적으로 구분되는 영역
            * footer : 문서 전체나 섹션의 푸터(마지막 부분)

        *시멘틱 태그를 사용해야하는 이유
            의미론적 마크업
                개발자 및 사용자 뿐만 아니라 검색엔진 등에 의미있는 정보의 그룹을 태그로 표현
                단순히 구역을 나누는 것 뿐만 아니라 '의미'를 가지는 태그들을 활용하기 위한 노력
                요소의 의미가 명확해지기 때문에 코드의 가독성을 높이고 유지보수를 쉽게 함
                검색 엔진 최적화를 위해서 메타태그, 시맨틱 태그 등을 통한 마크업을 효과적으로 활용해야함

    -> 텍스트로 작성된 코드가 랜더링을 통해 사용자가 볼 수 있는 웹사이트로 바뀜

    -> DOM(Document Object Model) 트리
        * 텍스트 파일인 HTML 문서를 브라우저에서 랜더링하기 위한 구조
            HTML 문서에 대한 모델을 구성
            HTML 문서 내의 각 요소에 접근 / 수정에 필요한 프로퍼티와 메서드를 제공함

    -> HTML 문서 구조화
        인사인 요소는 글자처럼 취급
        블록 요소는 한 줄 모두 사용

        텍스트 요소
            <a></a> href 속성을 활용하여 다른 url로 연결하는 하이퍼링크 생성
            <b></b> 굵은 글씨 요소
            <strong></strong> 중요한 강조하고자 하는 요소 (보통 굵은 글씨로 표현)
            <br></br> 텍스트 내에 줄 바꿈 생성
            <i></i> 기울임 글씨 요소
            <em></em> 중요한 강조하고자 하는 요소 (보통 기울임 글씨로 표현)
            <img> src 속성을 활용하여 이미지 표현
            <span></span> 의미없는 인라인 컨테이너

        그룹 컨텐츠
            <p></p> 하나의 문단
            <hr> 문단 레벨 요소에서의 제의 분리, 수평선으로 표현됨
            <ol></ol> 순서가 있는 리스트
            <ul></ul> 순서가 없는 리스트
            <pre></pre> HTML에 작성한 내용을 그대로 표현, 보통 고정폭 글꼴이 사용되고 공백 문자를 유지
            <blockquote></blockquote> 텍스트가 긴 인용문, 주로 들여쓰기를 한 것으로 표현됨
            <div></div> 의미 없는 블록 레벨 컨테이너
        
        form : <form>은 정보를 서버에 제출하기 위해 사용하는 태그
        <form> 기본 속성
            action : form을 처리할 서버의 url (데이터를 보낼 곳)
            method : 사용할 HTTP 메서드 (GET 또는 POST)
            enctype : method가 post인 경우 데이터의 유형
                application/x-www-form-urlencoded : 기본값
                multipart/form-data : 파일 전송 시 (input type이 file인 경우)
        
        input : 다양한 타입을 가지는 입력 데이터 유형과 위젯이 제공됨
        <input> 대표 속성
            name : form control에 적용되는 이름 (이름 / 값 페어로 전송됨)
            value : form control에 적용되는 값 (이름 / 값 페어로 전송됨)
            required, readonly, autofocus 등등
        input label : label을 클릭하여 input 자체의 초점을 맞추거나 활성화 시킬 수 있음
            사용자는 선택할 수 있는 영역이 늘어나 웹 / 모바일 환경에서 편하게 사용할 수 있음
            label과 input 입력의 관계가 시각적 뿐만 아니라 화면리더기에서도 label을 읽어
            쉽게 내용을 확인할 수 있도록 함
        <input>에 id 속성을, <label>에는 for 속성을 활용하여 상호 연관을 시킴
        input 유형 - 일반
            *일반적으로 입력을 받기 위하여 제공되며 타입별로 HTML 기본 검증 혹은 추가 속성을 활용할 수 있음
                *text : 일반 텍스트 입력
                *password : 입력 시 값이 보이지 않고 문자를 특수기호(*)로 표현
                *email : 이메일 형식이 아닌 경우 form 제출 불가
                *number : min, max, step 속성을 활용하여 숫자 범위 설정 가능
                *file : accept 속성을 황용하여 파일 타입 지정 가능
        일반적으로 label 태그와 함께 사용하여 선택 항목을 작성함
        동일 항목에 대하여는 name을 지정하고 선택된 항목에 대한 value를 지정해야 함

4) CSS

    -> 스타일을 지정하기 위한 언어
        *CSS 구문은 선택자를 통해 스타일을 지정할 HTML 요소를 선택
        *중괄호 안에서는 속성과 값, 하나의 쌍으로 이루어진 선언을 진행
        *각 쌍은 선택한 요소의 속성, 속성에 부여할 값을 의미
            속성 : 어떤 스타일 기능을 변경할 지 결정
            값 : 어떻게 스타일 기능을 변경할 지 결정

    -> CSS 정의 방법
        *인라인
            인라인을 쓰게 되면 실수가 잦아짐 (중복 발생, 찾기 힘들어짐)
        *내부참조
            내부 참조를 쓰게 되면 코드가 너무 길어짐
        *외부참조 (분리된 CSS파일)
            가장 많이 쓰는 방식 
    
    -> CSS 선택자
        *선택자 유형
            기본 선택자
                전체 선택자, 요소 선택자
                클래스 선택자, 아이디 선택자, 속성 선택자
            결합자
                자손 결합자, 자식 결합자
                일반 형제 결합자, 인접 형제 결합자
            의사 클래스/요소
                링크. 동적 의사 클래스
                구조적 의사 클래스, 기타 의사 클래스, 의사 엘리먼트, 속성 선택자
            요소 선택자
                HTML 태그를 직접 선택
            클래스 선택자
                마침표 문자로 시작하며, 해당 클래스가 적용된 항목을 선택
            아이디(ID) 선택자
                # 문자로 시작, 해당 아이디가 적용된 항목을 선택
                일반적으로 하나의 문서에 1번만 사용
                여러 번 사용해도 동작하지만, 단일 ID를 사용하는 것을 권장
            
    -> CSS 적용 우선순위
        CSS 우선순위를 아래오 ㅏ같이 그룹을 지어볼 수 있다.
            1. 중요도(Important)
                !Important
            2. 우선순위(Specificity)
                인라인 > id > class, 속성, psuedo-class > 요소, pseudo-element
            3. CSS 파일 로딩 순서

    -> CSS 상속
        CSS는 상속을 통해 부모 요소의 속성을 자식에게 상속한다.
            속성중에는 상속이 되는 것과 되지 않는 것들이 있다.
            상속 되는 것 : Text 관련 요소 (font, color, text-align), opacity, visibility 등
            상속 되지 않는 것 : Box model 관련 요소 (width, height, margin, padding, border, box-sizing, display), Position 관련 요소(position,top/right/bottom 등)
    
    -> CSS 기본 스타일
        px(픽셀) : 모니터 해상도의 한 화소인 '픽셀' 기준
                   픽셀의 크기는 변하지 않기 때문에 고정적인 단위
        % : 백분율 단위, 가변적인 레이아웃에서 자주 사용
        em : 상속의 영향을 받음, 배수 단위, 요소에 지정된 사이즈에 상대적인 사이즈를 가짐
        rem : 상속의 영향을 받지 않음, 최상위 요소의 사이즈를 기준으로 배수 단위를 가짐

    -> 크기 단위
        px : 브라우저의 크기를 변경해도 그대로 유지됨
        vw : 브라우저의 크기에 따라 크기가 변함

    -> 색상 단위
        색상 키워드 (대소문자를 구분하지 않음, res,blue,black과 같은 특정 색을 직접 글자로 나타냄)
        RGB 색상 (16진수 표기법 혹은 함수형 표기법을 사용해서 특정 색을 표현하는 방식)
        HSL 색상 (색상, 채도, 명도를 통해 특정 색을 표현하는 방식)

    -> Selectors 심화
        결합자
            자손 결합자
                selector A 하위의 모든 selector B 요소
            자식 결합자
                selector A 바로 아래의 selector B 요소
            일반 형제 결합자
                selectorA의 형제 요소 중 뒤에 위치하는 selectorB 요소를 모두 선택
            인접 형제 결합자
                selectorA의 형제 요소 중 바로 뒤에 위치하는 selectorB 요소를 선택

    -> CSS 박스 모델
        모든 요소는 네모(박스모델)이고,
        위에서부터 아래로, 왼쪽에서 오른쪽으로 쌓인다.

        모든 HTML 요소는 BOX형태로 이루어져 있음
        하나의 박스는 네개의 영역으로 이루어짐
            margin : 테두리 바깥의 외부 여백, 배경색을 지정할 수 없음 
            border : 테두리 영역 
            padding : 테두리 안쪽의 내부 여백, 요소에 적용된 배경색, 이미지는 padding까지 적용
            content : 글이나 이미지 등 요소의 실제 내용

        box-sizing
            기본적으로 모든 요소의 box-sizing은 content-box
                padding을 제외한 순수 content 영역만을 box로 지정
            다만, 우리가 일반적으로 영역을 볼 때, border 까지의 너비를 원함
                box-sizing을 border-box로 설정
        
    -> CSS display
        모든 요소는 네모(박스모델)이고, 좌측 상단에 배치
        display에 따라 크기와 배치가 달라진다

        대표적으로 활용되는 display
            display : blockquote
                줄 바꿈이 일어나는 요소
                화면 크기 전체의 가로 폭을 차지함
                블록 레벨 요소 안에 인라인 레벨 요소가 들어갈 수 있음
            display : inline
                줄 바꿈이 일어나지 않는 행의 일부 요소
                content 너비만큼 가로 폭을 차지
                width, height, margin-top, margin-bottom을 지정할 수 없음
                상하 여백은 line-height로 지정한다.
            display : inline-block
                block과 inline 레벨 요소의 특징을 모두 가짐
                inline처럼 한 줄에 표시할 수 있고, block처럼 width, height, margin 속성을 모두 지정할 수 있음
            display : none
                해당 요소를 화면에 표시하지 않고, 공간조차 부여하지 않음
                이와 비슷한 visibility : hidden은 해당 요소가 공간은 차지하나 화면에 표시만 하지 않는다.
    
    -> CSS Position
        문서 상에서 요소의 위치를 지정
        static : 모든 태그의 기본 값
            일반적인 요소의 배치 순서에 따름
            부모 요소 내에서 배치될 때는 부모 요소의 위치를 기준으로 배치
        
        relative, absolute, fixed, sticky는 좌표 프로퍼티를 이용하여 이동 가능

        1. relative : 상대 위치
            자기 자신의 static 위치를 기준으로 이동 (normal flow 유지)
            레이아웃에서 요소가 차지하는 공간은 static일 떄와 같음
        2. absolute : 절대 위치
            요소를 일반적인 문서 흐름에서 제거 후 레이아웃에 공간을 차지하지 않음
            static이 아닌 가장 가까이 있는 부모/조상 요소를 기준으로 이동
        3. fixed : 고정 위치
            요소를 일반적인 문서 흐름에서 제거 후 레이아웃에 공간을 차지하지 않음
            부모 요소와 관계없이  viewport를 기준으로 이동 (스크롤 시에도 항상 같은 곳에 위치)
        4. sticky : 스크롤에 따라 static -> fixed로 변경
            속성을 적용한 박스는 평소에 문서 안에서 position : static 상태와 같이 일반적인 흐름에 따르지만
            스크롤 위치가 임계점에 이르면, position : fixed와 같이 박스를 화면에 고정할 수 있는 속성

    -> CSS 원칙
        CSS 원칙 1,2 : Normal flow
            모든 요소는 네모,  좌측 상단에 배치
            display에 따라 크기와 배치가 달라짐
        CSS 원칙 3 
            position으로 위치의 기준을 변경
                relative : 본인의 원래 위치
                absolute : 특정 부모의 위치
                fixed : 화면의 위치
                sticky : 기본적으로 static이나 스크롤 이동에 따라 fixed로 변경
</div>
</details>

